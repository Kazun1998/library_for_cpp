---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: Algebra/Extended_Algebra.hpp
    title: Algebra/Extended_Algebra.hpp
  - icon: ':heavy_check_mark:'
    path: Max_Flow/Max_Flow.hpp
    title: "\u6700\u5927\u6D41"
  - icon: ':heavy_check_mark:'
    path: Max_Flow/Project_Selection_Problem.hpp
    title: Max_Flow/Project_Selection_Problem.hpp
  - icon: ':heavy_check_mark:'
    path: template/bitop.hpp
    title: template/bitop.hpp
  - icon: ':heavy_check_mark:'
    path: template/exception.hpp
    title: template/exception.hpp
  - icon: ':heavy_check_mark:'
    path: template/inout.hpp
    title: template/inout.hpp
  - icon: ':heavy_check_mark:'
    path: template/macro.hpp
    title: template/macro.hpp
  - icon: ':heavy_check_mark:'
    path: template/math.hpp
    title: template/math.hpp
  - icon: ':heavy_check_mark:'
    path: template/template.hpp
    title: template/template.hpp
  - icon: ':heavy_check_mark:'
    path: template/utility.hpp
    title: template/utility.hpp
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://yukicoder.me/problems/no/1984
    links:
    - https://yukicoder.me/problems/no/1984
  bundledCode: "#line 1 \"verify/yukicoder/1984.test.cpp\"\n#define PROBLEM \"https://yukicoder.me/problems/no/1984\"\
    \n\n#line 2 \"template/template.hpp\"\n\nusing namespace std;\n\n// intrinstic\n\
    #include <immintrin.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n\
    #include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include\
    \ <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include\
    \ <complex>\n#include <concepts>\n#include <cstdarg>\n#include <cstddef>\n#include\
    \ <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include\
    \ <deque>\n#include <fstream>\n#include <functional>\n#include <initializer_list>\n\
    #include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n\
    #include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include\
    \ <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <optional>\n\
    #include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include\
    \ <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include\
    \ <type_traits>\n#include <typeinfo>\n#include <unordered_map>\n#include <unordered_set>\n\
    #include <utility>\n#include <vector>\n\n// utility\n#line 2 \"template/utility.hpp\"\
    \n\nusing ll = long long;\n\n// a \u2190 max(a, b) \u3092\u5B9F\u884C\u3059\u308B\
    . a \u304C\u66F4\u65B0\u3055\u308C\u305F\u3089, \u8FD4\u308A\u5024\u304C true.\n\
    template<typename T, typename U>\ninline bool chmax(T &a, const U b){\n    return\
    \ (a < b ? a = b, 1: 0);\n}\n\n// a \u2190 min(a, b) \u3092\u5B9F\u884C\u3059\u308B\
    . a \u304C\u66F4\u65B0\u3055\u308C\u305F\u3089, \u8FD4\u308A\u5024\u304C true.\n\
    template<typename T, typename U>\ninline bool chmin(T &a, const U b){\n    return\
    \ (a > b ? a = b, 1: 0);\n}\n\n// a \u306E\u6700\u5927\u5024\u3092\u53D6\u5F97\
    \u3059\u308B.\ntemplate<typename T>\ninline T max(const vector<T> &a){\n    if\
    \ (a.empty()) throw invalid_argument(\"vector is empty.\");\n\n    return *max_element(a.begin(),\
    \ a.end());\n}\n\n// vector<T> a \u306E\u6700\u5C0F\u5024\u3092\u53D6\u5F97\u3059\
    \u308B.\ntemplate<typename T>\ninline T min(const vector<T> &a){\n    if (a.empty())\
    \ throw invalid_argument(\"vector is empty.\");\n\n    return *min_element(a.begin(),\
    \ a.end());\n}\n\n// vector<T> a \u306E\u6700\u5927\u5024\u306E\u30A4\u30F3\u30C7\
    \u30C3\u30AF\u30B9\u3092\u53D6\u5F97\u3059\u308B.\ntemplate<typename T>\ninline\
    \ size_t argmax(const vector<T> &a){\n    if (a.empty()) throw std::invalid_argument(\"\
    vector is empty.\");\n\n    return distance(a.begin(), max_element(a.begin(),\
    \ a.end()));\n}\n\n// vector<T> a \u306E\u6700\u5C0F\u5024\u306E\u30A4\u30F3\u30C7\
    \u30C3\u30AF\u30B9\u3092\u53D6\u5F97\u3059\u308B.\ntemplate<typename T>\ninline\
    \ size_t argmin(const vector<T> &a){\n    if (a.empty()) throw invalid_argument(\"\
    vector is empty.\");\n\n    return distance(a.begin(), min_element(a.begin(),\
    \ a.end()));\n}\n#line 61 \"template/template.hpp\"\n\n// math\n#line 2 \"template/math.hpp\"\
    \n\n// \u6F14\u7B97\u5B50\ntemplate<typename T>\nT add(const T &x, const T &y)\
    \ { return x + y; }\n\ntemplate<typename T>\nT sub(const T &x, const T &y) { return\
    \ x - y; }\n\ntemplate<typename T>\nT mul(const T &x, const T &y) { return x *\
    \ y; }\n\ntemplate<typename T>\nT neg(const T &x) { return -x; }\n\ntemplate<typename\
    \ T>\nT bitwise_and(const T &x, const T &y) { return x & y; }\n\ntemplate<typename\
    \ T>\nT bitwise_or(const T &x, const T &y) { return x | y; }\n\ntemplate<typename\
    \ T>\nT bitwise_xor(const T &x, const T &y) { return x ^ y; }\n\n// \u9664\u7B97\
    \u306B\u95A2\u3059\u308B\u95A2\u6570\n\n// floor(x / y) \u3092\u6C42\u3081\u308B\
    .\ntemplate<typename T, typename U>\nauto div_floor(T x, U y){\n    return x /\
    \ y - ((x % y != 0) && ((x < 0) != (y < 0)));\n}\n\n// ceil(x / y) \u3092\u6C42\
    \u3081\u308B.\ntemplate<typename T, typename U>\nauto div_ceil(T x, U y){\n  \
    \  return x / y + ((x % y != 0) && ((x < 0) == (y < 0)));\n}\n\n// x \u3092 y\
    \ \u3067\u5272\u3063\u305F\u4F59\u308A\u3092\u6C42\u3081\u308B.\ntemplate<typename\
    \ T, typename U>\nauto safe_mod(T x, U y){\n    auto q = div_floor(x, y);\n  \
    \  return x - q * y ;\n}\n\n// x \u3092 y \u3067\u5272\u3063\u305F\u5546\u3068\
    \u4F59\u308A\u3092\u6C42\u3081\u308B.\ntemplate<typename T, typename U>\nauto\
    \ divmod(T x, U y){\n    auto q = div_floor(x, y);\n    return make_pair(q, x\
    \ - q * y);\n}\n\n// \u56DB\u6368\u4E94\u5165\u3092\u6C42\u3081\u308B.\ntemplate<typename\
    \ T, typename U>\nauto round(T x, U y){\n    auto [q, r] = divmod(x, y);\n   \
    \ if (y < 0) return (r <= div_floor(y, 2)) ? q + 1 : q;\n    return (r >= div_ceil(y,\
    \ 2)) ? q + 1 : q;\n}\n\n// \u6307\u6570\u306B\u95A2\u3059\u308B\u95A2\u6570\n\
    \n// x \u306E y \u4E57\u3092\u6C42\u3081\u308B.\nll intpow(ll x, ll y){\n    ll\
    \ a = 1;\n    while (y){\n        if (y & 1) { a *= x; }\n        x *= x;\n  \
    \      y >>= 1;\n    }\n    return a;\n}\n\n// x \u306E y \u4E57\u3092 z \u3067\
    \u5272\u3063\u305F\u4F59\u308A\u3092\u6C42\u3081\u308B.\nll modpow(ll x, ll y,\
    \ ll z){\n    ll a = 1;\n    while (y){\n        if (y & 1) { (a *= x) %= z; }\n\
    \        (x *= x) %= z;\n        y >>= 1;\n    }\n    return a;\n}\n\n// x \u306E\
    \ y \u4E57\u3092 z \u3067\u5272\u3063\u305F\u4F59\u308A\u3092\u6C42\u3081\u308B\
    .\ntemplate<typename T, typename U>\nT modpow(T x, U y, T z) {\n    T a = 1;\n\
    \    while (y) {\n        if (y & 1) { (a *= x) %= z; }\n\n        (x *= x) %=\
    \ z;\n        y >>= 1;\n    }\n\n    return a;\n}\n\ntemplate<typename T>\nT sum(const\
    \ vector<T> &X) {\n    T y = T(0);\n    for (auto &&x: X) { y += x; }\n    return\
    \ y;\n}\n\n// a x + b y = gcd(a, b) \u3092\u6E80\u305F\u3059\u6574\u6570\u306E\
    \u7D44 (a, b) \u306B\u5BFE\u3057\u3066, (x, y, gcd(a, b)) \u3092\u6C42\u3081\u308B\
    .\ntemplate<integral T>\ntuple<T, T, T> Extended_Euclid(T a, T b) {\n    T s =\
    \ 1, t = 0, u = 0, v = 1;\n    while (b) {\n        T q;\n        tie(q, a, b)\
    \ = make_tuple(div_floor(a, b), b, safe_mod(a, b));\n        tie(s, t) = make_pair(t,\
    \ s - q * t);\n        tie(u, v) = make_pair(v, u - q * v);\n    }\n\n    return\
    \ make_tuple(s, u, a);\n}\n\n// floor(sqrt(N)) \u3092\u6C42\u3081\u308B (N < 0\
    \ \u306E\u3068\u304D\u306F, 0 \u3068\u3059\u308B).\nll isqrt(const ll &N) { \n\
    \    if (N <= 0) { return 0; }\n\n    ll x = sqrt(N);\n    while ((x + 1) * (x\
    \ + 1) <= N) { x++; }\n    while (x * x > N) { x--; }\n\n    return x;\n}\n\n\
    // floor(sqrt(N)) \u3092\u6C42\u3081\u308B (N < 0 \u306E\u3068\u304D\u306F, 0\
    \ \u3068\u3059\u308B).\nll floor_sqrt(const ll &N) { return isqrt(N); }\n\n//\
    \ ceil(sqrt(N)) \u3092\u6C42\u3081\u308B (N < 0 \u306E\u3068\u304D\u306F, 0 \u3068\
    \u3059\u308B).\nll ceil_sqrt(const ll &N) {\n    ll x = isqrt(N);\n    return\
    \ x * x == N ? x : x + 1;\n}\n#line 64 \"template/template.hpp\"\n\n// inout\n\
    #line 1 \"template/inout.hpp\"\n// \u5165\u51FA\u529B\ntemplate<class... T>\n\
    void input(T&... a){ (cin >> ... >> a); }\n\nvoid print(){ cout << \"\\n\"; }\n\
    \ntemplate<class T, class... Ts>\nvoid print(const T& a, const Ts&... b){\n  \
    \  cout << a;\n    (cout << ... << (cout << \" \", b));\n    cout << \"\\n\";\n\
    }\n\ntemplate<typename T, typename U>\nistream &operator>>(istream &is, pair<T,\
    \ U> &P){\n    is >> P.first >> P.second;\n    return is;\n}\n\ntemplate<typename\
    \ T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &P){\n   \
    \ os << P.first << \" \" << P.second;\n    return os;\n}\n\ntemplate<typename\
    \ T>\nvector<T> vector_input(int N, int index){\n    vector<T> X(N+index);\n \
    \   for (int i=index; i<index+N; i++) cin >> X[i];\n    return X;\n}\n\ntemplate<typename\
    \ T>\nistream &operator>>(istream &is, vector<T> &X){\n    for (auto &x: X) {\
    \ is >> x; }\n    return is;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream\
    \ &os, const vector<T> &X){\n    int s = (int)X.size();\n    for (int i = 0; i\
    \ < s; i++) { os << (i ? \" \" : \"\") << X[i]; }\n    return os;\n}\n\ntemplate<typename\
    \ T>\nostream &operator<<(ostream &os, const unordered_set<T> &S){\n    int i\
    \ = 0;\n    for (T a: S) {os << (i ? \" \": \"\") << a; i++;}\n    return os;\n\
    }\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const set<T> &S){\n\
    \    int i = 0;\n    for (T a: S) { os << (i ? \" \": \"\") << a; i++; }\n   \
    \ return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const\
    \ unordered_multiset<T> &S){\n    int i = 0;\n    for (T a: S) { os << (i ? \"\
    \ \": \"\") << a; i++; }\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream\
    \ &os, const multiset<T> &S){\n    int i = 0;\n    for (T a: S) { os << (i ? \"\
    \ \": \"\") << a; i++; }\n    return os;\n}\n\ntemplate<typename T>\nstd::vector<T>\
    \ input_vector(size_t n, size_t offset = 0) {\n    std::vector<T> res;\n    //\
    \ \u6700\u521D\u306B\u5FC5\u8981\u306A\u5168\u5BB9\u91CF\u3092\u78BA\u4FDD\uFF08\
    \u518D\u78BA\u4FDD\u3092\u9632\u3050\uFF09\n    res.reserve(n + offset);\n   \
    \ // offset \u5206\u3092\u30C7\u30D5\u30A9\u30EB\u30C8\u5024\u3067\u57CB\u3081\
    \u308B\uFF08\u7279\u5225 indexed \u7528\uFF09\n    res.assign(offset, T());\n\
    \    \n    for (size_t i = 0; i < n; ++i) {\n        T el;\n        if (!(std::cin\
    \ >> el)) break;\n        res.push_back(std::move(el));\n    }\n    return res;\n\
    }\n#line 67 \"template/template.hpp\"\n\n// macro\n#line 2 \"template/macro.hpp\"\
    \n\n// \u30DE\u30AF\u30ED\u306E\u5B9A\u7FA9\n#define all(x) x.begin(), x.end()\n\
    #define len(x) ll(x.size())\n#define elif else if\n#define unless(cond) if (!(cond))\n\
    #define until(cond) while (!(cond))\n#define loop while (true)\n\n// \u30AA\u30FC\
    \u30D0\u30FC\u30ED\u30FC\u30C9\u30DE\u30AF\u30ED\n#define overload2(_1, _2, name,\
    \ ...) name\n#define overload3(_1, _2, _3, name, ...) name\n#define overload4(_1,\
    \ _2, _3, _4, name, ...) name\n#define overload5(_1, _2, _3, _4, _5, name, ...)\
    \ name\n\n// \u7E70\u308A\u8FD4\u3057\u7CFB\n#define rep1(n) for (ll i = 0; i\
    \ < n; i++)\n#define rep2(i, n) for (ll i = 0; i < n; i++)\n#define rep3(i, a,\
    \ b) for (ll i = a; i < b; i++)\n#define rep4(i, a, b, c) for (ll i = a; i < b;\
    \ i += c)\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n\
    \n#define foreach1(x, a) for (auto &&x: a)\n#define foreach2(x, y, a) for (auto\
    \ &&[x, y]: a)\n#define foreach3(x, y, z, a) for (auto &&[x, y, z]: a)\n#define\
    \ foreach4(x, y, z, w, a) for (auto &&[x, y, z, w]: a)\n#define foreach(...) overload5(__VA_ARGS__,\
    \ foreach4, foreach3, foreach2, foreach1)(__VA_ARGS__)\n#line 70 \"template/template.hpp\"\
    \n\n// bitop\n#line 2 \"template/bitop.hpp\"\n\n// \u975E\u8CA0\u6574\u6570 x\
    \ \u306E bit legnth \u3092\u6C42\u3081\u308B.\nll bit_length(ll x) {\n    if (x\
    \ == 0) { return 0; }\n    return (sizeof(long) * CHAR_BIT) - __builtin_clzll(x);\n\
    }\n\n// \u975E\u8CA0\u6574\u6570 x \u306E popcount \u3092\u6C42\u3081\u308B.\n\
    ll popcount(ll x) { return __builtin_popcountll(x); }\n\n// \u6B63\u306E\u6574\
    \u6570 x \u306B\u5BFE\u3057\u3066, floor(log2(x)) \u3092\u6C42\u3081\u308B.\n\
    ll floor_log2(ll x) { return bit_length(x) - 1; }\n\n// \u6B63\u306E\u6574\u6570\
    \ x \u306B\u5BFE\u3057\u3066, ceil(log2(x)) \u3092\u6C42\u3081\u308B.\nll ceil_log2(ll\
    \ x) { return bit_length(x - 1); }\n\n// x \u306E\u7B2C k \u30D3\u30C3\u30C8\u3092\
    \u53D6\u5F97\u3059\u308B\nint get_bit(ll x, int k) { return (x >> k) & 1; }\n\n\
    // x \u306E\u30D3\u30C3\u30C8\u5217\u3092\u53D6\u5F97\u3059\u308B.\n// k \u306F\
    \u30D3\u30C3\u30C8\u5217\u306E\u9577\u3055\u3068\u3059\u308B.\nvector<int> get_bits(ll\
    \ x, int k) {\n    vector<int> bits(k);\n    rep(i, k) {\n        bits[i] = x\
    \ & 1;\n        x >>= 1;\n    }\n\n    return bits;\n}\n\n// x \u306E\u30D3\u30C3\
    \u30C8\u5217\u3092\u53D6\u5F97\u3059\u308B.\nvector<int> get_bits(ll x) { return\
    \ get_bits(x, bit_length(x)); }\n#line 73 \"template/template.hpp\"\n\n// exception\n\
    #line 2 \"template/exception.hpp\"\n\nclass NotExist: public exception {\n   \
    \ private:\n    string message;\n\n    public:\n    NotExist() : message(\"\u6C42\
    \u3081\u3088\u3046\u3068\u3057\u3066\u3044\u305F\u3082\u306E\u306F\u5B58\u5728\
    \u3057\u307E\u305B\u3093.\") {}\n\n    const char* what() const noexcept override\
    \ {\n        return message.c_str();\n    }\n};\n#line 2 \"Max_Flow/Project_Selection_Problem.hpp\"\
    \n\n#line 2 \"Algebra/Extended_Algebra.hpp\"\n\n#line 4 \"Algebra/Extended_Algebra.hpp\"\
    \n\nclass IndeterminateOperationError : public std::runtime_error {\n    public:\n\
    \    IndeterminateOperationError(const std::string& msg): std::runtime_error(msg)\
    \ {}\n};\n\ntemplate<typename R>\nstruct Extended_Algebra {\n    R val;\n    signed\
    \ char inf_flag; // 0: finite, 1: +inf, -1: -inf\n    constexpr Extended_Algebra(R\
    \ val, signed char inf_flag): val(val), inf_flag(inf_flag) {}\n\n    public:\n\
    \    constexpr Extended_Algebra(): val(R()), inf_flag(0) {}\n    constexpr Extended_Algebra(R\
    \ val): val(val), inf_flag(0) {}\n\n    constexpr Extended_Algebra operator-()\
    \ const { return Extended_Algebra(-val, -inf_flag); }\n\n    static constexpr\
    \ Extended_Algebra inf = Extended_Algebra(R(), 1);\n\n    constexpr bool is_finite()\
    \ const { return inf_flag == 0; }\n    constexpr bool is_infinite() const { return\
    \ !is_finite(); }\n\n    constexpr bool is_positive(const bool zero = false) const\
    \ {\n        if(is_infinite()) { return inf_flag > 0; }\n\n        return zero\
    \ ? val >= R() : val > R();\n    }\n\n    constexpr bool is_negative(const bool\
    \ zero = false) const {\n        if(is_infinite()) { return inf_flag < 0; }\n\n\
    \        return zero ? val <= R() : val < R();\n    }\n\n    constexpr bool is_positive_infinite()\
    \ const { return inf_flag == 1; }\n    constexpr bool is_negative_infinite() const\
    \ { return inf_flag == -1; }\n\n    constexpr inline bool is_zero() const { return\
    \ inf_flag == 0 && val == R(); }\n\n    constexpr Extended_Algebra& operator+=(const\
    \ Extended_Algebra &rhs) {\n        if (is_positive_infinite() && rhs.is_negative_infinite())\
    \ {\n            throw IndeterminateOperationError(\"Extended_Algebra: Indeterminate\
    \ form (inf + (-inf))\");\n        }\n        if (is_negative_infinite() && rhs.is_positive_infinite())\
    \ {\n            throw IndeterminateOperationError(\"Extended_Algebra: Indeterminate\
    \ form ((-inf) + inf)\");\n        }\n\n        if (is_finite() && rhs.is_finite())\
    \ { val += rhs.val; }\n        else if (is_positive_infinite() || rhs.is_positive_infinite())\
    \ { inf_flag = 1; }\n        else if (is_negative_infinite() || rhs.is_negative_infinite())\
    \ { inf_flag = -1; }\n\n        return *this;\n    }\n\n    friend constexpr Extended_Algebra\
    \ operator+(const Extended_Algebra &lhs, const Extended_Algebra &rhs) { return\
    \ Extended_Algebra(lhs) += rhs; }\n\n    constexpr Extended_Algebra& operator-=(const\
    \ Extended_Algebra &rhs) {\n        if (this->is_positive_infinite() && rhs.is_positive_infinite())\
    \ { \n            throw IndeterminateOperationError(\"Extended_Algebra: Indeterminate\
    \ form (inf - inf)\");\n        }\n        if (this->is_negative_infinite() &&\
    \ rhs.is_negative_infinite()) {\n            throw IndeterminateOperationError(\"\
    Extended_Algebra: Indeterminate form ((-inf) - (-inf))\");\n        }\n\n    \
    \    if (is_finite() && rhs.is_finite()) { val -= rhs.val; }\n        else if\
    \ (is_positive_infinite() || rhs.is_negative_infinite()) { inf_flag = 1; }\n \
    \       else if (is_negative_infinite() || rhs.is_positive_infinite()) { inf_flag\
    \ = -1; }\n\n        return *this;\n    }\n\n    friend constexpr Extended_Algebra\
    \ operator-(const Extended_Algebra &lhs, const Extended_Algebra &rhs) { return\
    \ Extended_Algebra(lhs) -= rhs; }\n\n    constexpr Extended_Algebra& operator*=(const\
    \ Extended_Algebra &rhs) {\n        if (is_zero() || rhs.is_zero()) {\n      \
    \      val = R();\n            inf_flag = 0;\n            return *this;\n    \
    \    }\n\n        if (is_finite() && rhs.is_finite()) { val *= rhs.val; return\
    \ *this; }\n\n        if (is_positive() == rhs.is_positive()) { inf_flag = 1;\
    \ }\n        else { inf_flag = -1; }\n\n        return *this;\n    }\n\n    friend\
    \ constexpr Extended_Algebra operator*(const Extended_Algebra &lhs, const Extended_Algebra\
    \ &rhs) { return Extended_Algebra(lhs) *= rhs; }\n\n    constexpr Extended_Algebra&\
    \ operator/=(const Extended_Algebra &rhs) {\n        // 0-1. \u672A\u5B9A\u7FA9\
    \u5F62: (\xB1 inf) / (\xB1 inf)\n        if (this->is_infinite() && rhs.is_infinite())\
    \ {\n            throw IndeterminateOperationError(\"Extended_Algebra: Indeterminate\
    \ form (inf / inf)\");\n        }\n        // 0-2. \u672A\u5B9A\u7FA9\u5F62: 0\
    \ / 0\n        if (this->is_zero() && rhs.is_zero()) {\n            throw IndeterminateOperationError(\"\
    Extended_Algebra: Indeterminate form (0 / 0)\");\n        }\n\n        // 1. \u30BC\
    \u30ED\u9664\u7B97: finite (non-zero) / 0 -> \xB1inf\n        if (rhs.is_zero())\
    \ {\n            // \u5206\u6BCD\u304C 0 \u3067\u3042\u308B\u304C, 0-2 \u3092\u901A\
    \u308A\u629C\u3051\u3066\u3044\u308B\u306E\u3067, \u5206\u5B50\u304C 0 \u306B\u306F\
    \u306A\u308A\u5F97\u306A\u3044.\n            inf_flag = is_positive() ? 1 : -1;\n\
    \            val = R();\n            return *this;\n        }\n\n        // 2.\
    \ \u3069\u3061\u3089\u3082\u6709\u9650 (\u5206\u6BCD != 0)\n        if (is_finite()\
    \ && rhs.is_finite()) { \n            // \u30BC\u30ED\u9664\u7B97\u306F\u4E0A\u8A18\
    \ 1 \u3067\u51E6\u7406\u6E08\u307F\n            val /= rhs.val; \n           \
    \ return *this;\n        }\n\n        // 3. \u7121\u9650\u5927\u3092\u542B\u3080\
    \u78BA\u5B9A\u7684\u306A\u8A08\u7B97\n        // inf / finite (non-zero) \u307E\
    \u305F\u306F finite (zero) / inf\n        val = R(); // \u7D50\u679C\u306F inf\
    \ / 0\n\n        if (this->is_infinite() && rhs.is_finite()) {\n            //\
    \ inf / finite -> \u7B26\u53F7\u306F\u4E57\u7B97\u3068\u540C\u3058\n         \
    \   inf_flag = (is_positive() == rhs.is_positive()) ? 1 : -1;\n        } else\
    \ { // finite / inf -> 0 (\u65E2\u306B is_zero()\u3067\u51E6\u7406\u3055\u308C\
    \u3066\u3044\u308B\u3079\u304D\u3060\u304C\u5B89\u5168\u306E\u305F\u3081)\n  \
    \          inf_flag = 0;\n        }\n\n        return *this;\n    }\n\n    //\
    \ \u975E\u8907\u5408\u6F14\u7B97\u5B50\n    friend constexpr Extended_Algebra\
    \ operator/(const Extended_Algebra &lhs, const Extended_Algebra &rhs) {  return\
    \ Extended_Algebra(lhs) /= rhs; }\n\n    // \u6BD4\u8F03\n    friend constexpr\
    \ bool operator==(const Extended_Algebra &lhs, const Extended_Algebra &rhs) {\n\
    \        if (lhs.inf_flag != rhs.inf_flag) { return false; }\n\n        if (lhs.is_finite())\
    \ { return lhs.val == rhs.val; }\n\n        return true;\n    }\n\n    friend\
    \ constexpr bool operator<(const Extended_Algebra &lhs, const Extended_Algebra\
    \ &rhs) {\n        if (lhs.inf_flag != rhs.inf_flag) { return lhs.inf_flag < rhs.inf_flag;\
    \ }\n\n        if (lhs.is_finite()) { return lhs.val < rhs.val; }\n\n        return\
    \ false;\n    }\n\n    friend constexpr bool operator!=(const Extended_Algebra\
    \ &lhs, const Extended_Algebra &rhs) {return !(lhs == rhs);}\n    friend constexpr\
    \ bool operator> (const Extended_Algebra &lhs, const Extended_Algebra &rhs) {return\
    \ rhs < lhs;}\n    friend constexpr bool operator<=(const Extended_Algebra &lhs,\
    \ const Extended_Algebra &rhs) {return (lhs < rhs) || (lhs == rhs);}\n    friend\
    \ constexpr bool operator>=(const Extended_Algebra &lhs, const Extended_Algebra\
    \ &rhs) {return (lhs > rhs) || (lhs == rhs);}\n\n    // \u51FA\u529B\n    friend\
    \ ostream &operator<<(ostream &os, const Extended_Algebra &x) {\n        if (x.is_positive_infinite())\
    \ { return os << \"inf\"; }\n        if (x.is_negative_infinite()) { return os\
    \ << \"-inf\"; }\n        return os << x.val;\n    }\n};\n#line 2 \"Max_Flow/Max_Flow.hpp\"\
    \n\n#line 4 \"Max_Flow/Max_Flow.hpp\"\n\nnamespace max_flow {\n    template<typename\
    \ Cap>\n    struct Arc {\n        int id, source, target;\n        Cap cap, flow;\n\
    \        bool direction;\n        Arc* rev;\n\n        Arc(int id, int source,\
    \ int target, Cap cap, Cap flow, bool direction):\n            id(id), source(source),\
    \ target(target), cap(cap), flow(flow), direction(direction), rev(nullptr) {}\n\
    \n        inline bool is_flowable() const { return flow < cap; }\n        inline\
    \ Cap remain() const { return cap - flow; }\n\n        void push(Cap d) {\n  \
    \          flow += d;\n            rev->flow -= d;\n        }\n    };\n\n    template<typename\
    \ Cap>\n    struct Max_Flow {\n        private:\n        using V = int;\n    \
    \    vector<vector<Arc<Cap>*>> adj_out;\n        vector<Arc<Cap>*> arcs;\n   \
    \     vector<int> level, iter;\n\n        bool bfs(const V s, const V t) {\n \
    \           level.assign(order(), -1);\n            queue<V> Q;\n\n          \
    \  Q.push(s);\n            level[s] = 0;\n\n            while (!Q.empty()) {\n\
    \                V v = Q.front(); Q.pop();\n\n                for (Arc<Cap>* arc:\
    \ adj_out[v]) {\n                    unless(arc->is_flowable() && level[arc->target]\
    \ == -1) { continue; }\n\n                    level[arc->target] = level[v] +\
    \ 1;\n                    if (arc->target == t) { return true; }\n\n         \
    \           Q.push(arc->target);\n                }\n            }\n\n       \
    \     return false;\n        }\n\n        Cap dfs(const V v, const V t, const\
    \ Cap f) {\n            if (v == t) { return f; }\n\n            for (int i =\
    \ iter[v]; i < adj_out[v].size(); ++i) {\n                Arc<Cap>* arc = adj_out[v][i];\n\
    \n                unless(arc->is_flowable() && level[v] < level[arc->target])\
    \ { continue; }\n\n                Cap d = (f == -1) ? dfs(arc->target, t, arc->remain())\
    \ : dfs(arc->target, t, min(f, arc->remain()));\n\n                unless(d >\
    \ 0) { continue; }\n\n                arc->push(d);\n                return d;\n\
    \            }\n\n            return 0;\n        }\n\n        public:\n      \
    \  Max_Flow(int N = 0) {\n            adj_out.resize(N);\n            level.resize(N);\n\
    \            iter.resize(N);\n        }\n\n        ~Max_Flow() {\n           \
    \ for (Arc<Cap>* arc : arcs) {\n                if (arc->rev) { delete arc->rev;\
    \ }\n                delete arc;\n            }\n        }\n\n        inline int\
    \ order() const { return adj_out.size(); }\n        inline int size() const {\
    \ return arcs.size(); }\n\n        int add_arc(const V u, const V v, const Cap\
    \ cap) {\n            int m = size();\n\n            Arc<Cap>* arc = new Arc<Cap>(m,\
    \ u, v, cap, 0, true);\n            Arc<Cap>* rev_arc = new Arc<Cap>(m, v, u,\
    \ 0, 0, false);\n\n            arc->rev = rev_arc;\n            rev_arc->rev =\
    \ arc;\n\n            adj_out[u].emplace_back(arc);\n            adj_out[v].emplace_back(rev_arc);\n\
    \            arcs.emplace_back(arc);\n\n            return m;\n        }\n\n \
    \       int add_vertex() {\n            adj_out.emplace_back({});\n          \
    \  level.emplace_back(-1);\n            iter.emplace_back(0);\n\n            return\
    \ order() - 1;\n        }\n\n        Cap max_flow(const V source, const V target)\
    \ {\n            Cap flow = 0;\n            while (bfs(source, target)) {\n  \
    \              iter.assign(order(), 0);\n                Cap f;\n            \
    \    while ((f = dfs(source, target, -1)) > 0) {\n                    flow +=\
    \ f;\n                }\n            }\n\n            return flow;\n        }\n\
    \n        Cap max_flow(const V source, const V target, Cap flow_limit) {\n   \
    \         Cap flow = 0;\n            while (flow < flow_limit && bfs(source, target))\
    \ {\n                iter.assign(order(), 0);\n                Cap f;\n      \
    \          while ((f = dfs(source, target, -1)) > 0) {\n                    flow\
    \ += f;\n                }\n            }\n\n            return flow;\n      \
    \  }\n\n        vector<vector<tuple<int, V, Cap>>> get_flow() const {\n      \
    \      vector<vector<tuple<int, V, Cap>>> flow(order());\n\n            for (Arc<Cap>*\
    \ arc: arcs) {\n                flow[arc->source].emplace_back(\n            \
    \        arc->id,\n                    arc->target,\n                    arc->flow\n\
    \                );\n            }\n\n            return flow;\n        }\n\n\
    \        vector<bool> min_cut(const int s) {\n            vector<bool> group(order(),\
    \ true); group[s] = false;\n\n            deque<V> Q{s};\n\n            while\
    \ (!Q.empty()) {\n                V x = Q.front(); Q.pop_front();\n\n        \
    \        for (Arc<Cap>* arc: adj_out[x]) {\n                    V y = arc->target;\n\
    \                    unless(arc->is_flowable() && group[y]) { continue; }\n\n\
    \                    group[y] = false;\n                    Q.emplace_back(y);\n\
    \                }\n            }\n\n            return group;\n        }\n  \
    \  };\n}\n#line 5 \"Max_Flow/Project_Selection_Problem.hpp\"\n\nnamespace projection_selection_problem\
    \ {\n    template<typename T>\n    class Project_Selection_Problem {\n       \
    \ using ET = Extended_Algebra<T>;\n        using V = int;\n\n        private:\n\
    \        int N, ver_num;\n        V source, target;\n        ET base;\n      \
    \  vector<vector<ET>> indivi;\n        vector<pair<pair<V, V>, ET>> mutual;\n\
    \        vector<vector<bool>> guard;\n\n        V add_vertex_inner() {\n     \
    \       V n = ver_num++;\n            indivi.emplace_back(vector<ET>{ET(0), ET(0)});\n\
    \            guard.emplace_back(vector<bool>{true, true});\n            return\
    \ n;\n        }\n\n        public:\n        ET ans;\n        vector<bool> choice;\n\
    \        Project_Selection_Problem(const int N):\n            N(N), ver_num(N\
    \ + 2), source(N), target(N + 1),\n            base(0), indivi(N + 2, { ET(0),\
    \ ET(0) }), guard(N + 2, {false, false})\n            {}\n\n        V add_vertex()\
    \ {\n            V n = ver_num++;\n            indivi.emplace_back(vector<ET>{ET(0),\
    \ ET(0)});\n            guard.emplace_back(vector<bool>{false, false});\n    \
    \        return n;\n        }\n\n        vector<V> add_vertices(const int k) {\n\
    \            vector<V> ids;\n            for (int i = 1; i <= k; i++) {\n    \
    \            ids.emplace_back(add_vertex());\n            }\n\n            return\
    \ ids;\n        }\n\n        void set_zero_one(const V x, const V y, ET a) {\n\
    \            assert(a.is_negative(true));\n\n            pair<V, V> arc(x, y);\n\
    \            mutual.emplace_back(arc, -a);\n        }\n\n        inline void set_zero(const\
    \ V x, const ET a) { indivi[x][0] += a; }\n        inline void set_one(const V\
    \ x, const ET a) { indivi[x][1] += a; }\n\n        void set_all_zero(const vector<V>&\
    \ Xs, const ET a) {\n            assert(a.is_positive(true));\n\n            V\
    \ k = add_vertex_inner();\n            base += a;\n\n            indivi[k][0]\
    \ -= a;\n            guard[k][0] = false;\n\n            for(V x: Xs) {\n    \
    \            pair<V, V> arc(k, x);\n                mutual.emplace_back(arc, ET::inf);\n\
    \            }\n        }\n\n        void set_all_one(const vector<V>& Xs, const\
    \ ET a) {\n            assert(a.is_positive());\n\n            V k = add_vertex_inner();\n\
    \            base += a;\n\n            indivi[k][1] -= a;\n            guard[k][1]\
    \ = false;\n\n            for(V x: Xs) {\n                pair<V, V> arc(x, k);\n\
    \                mutual.emplace_back(arc, ET::inf);\n            }\n        }\n\
    \n        void set_not_equal(const V x, const V y, const ET a) {\n           \
    \ assert(a.is_negative(true));\n\n            set_zero_one(x, y, a);\n       \
    \     set_zero_one(y, x, a);\n        }\n\n        void set_equal(const V x, const\
    \ V y, const ET a) {\n            set_all_zero({x, y}, a);\n            set_all_one({x,\
    \ y}, a);\n        }\n\n        void ban_zero(const V x) { set_zero(x, -ET::inf);\
    \ }\n        void ban_one(const V x) { set_one(x, -ET::inf); }\n\n        void\
    \ force_zero(const V x) { ban_one(x); }\n        void force_one(const V x) { ban_zero(x);\
    \ }\n\n        void solve() {\n            max_flow::Max_Flow<ET> F(ver_num);\n\
    \n            for (int i = 0; i < N; i++) {\n                F.add_arc(source,\
    \ i, 0);\n                F.add_arc(i, target, 0);\n\n                if (indivi[i][0].is_positive(true))\
    \ {\n                    base += indivi[i][0];\n                    F.add_arc(source,\
    \ i, indivi[i][0]);\n                } else {\n                    F.add_arc(i,\
    \ target, -indivi[i][0]);\n                }\n\n                if (indivi[i][1].is_positive(true))\
    \ {\n                    base += indivi[i][1];\n                    F.add_arc(i,\
    \ target, indivi[i][1]);\n                } else {\n                    F.add_arc(source,\
    \ i, -indivi[i][1]);\n                }\n            }\n\n            for (int\
    \ i = target + 1; i < ver_num; i++) {\n                if (!guard[i][0]) { F.add_arc(source,\
    \ i, -indivi[i][0]); }\n                if (!guard[i][1]) { F.add_arc(i, target,\
    \ -indivi[i][1]); }\n            }\n\n            for(auto &[arc, a]: mutual)\
    \ {\n                V x, y;\n                tie(x, y) = arc;\n             \
    \   F.add_arc(x, y, a);\n            }\n\n            ET alpha = F.max_flow(source,\
    \ target);\n            ans = base - alpha;\n            choice = F.min_cut(source);\n\
    \        }\n    };\n}\n#line 5 \"verify/yukicoder/1984.test.cpp\"\n\nusing namespace\
    \ projection_selection_problem;\n\nvoid verify() {\n    // \u5909\u6570\u4EE3\u5165\
    \n    int N, M, K, P; cin >> N >> M >> K >> P;\n    vector<ll> E(N + 1), F(M +\
    \ 1), V(K + 1);\n    for (int i = 1; i <= N; i++) { cin >> E[i]; }\n    for (int\
    \ j = 1; j <= M; j++) { cin >> F[j]; }\n    for (int k = 1; k <= K; k++) { cin\
    \ >> V[k]; }\n\n    vector<int> L(N + 1);\n    vector<vector<int>> A(N + 1);\n\
    \n    for (int i = 1; i <= N; i++) {\n        cin >> L[i];\n        A[i].resize(L[i]);\n\
    \        for (int t = 0; t < L[i]; t++) { cin >> A[i][t]; }\n    }\n\n    vector<int>\
    \ I(P), J(P);\n    for (int p = 0; p < P; p++) { cin >> I[p] >> J[p]; }\n\n  \
    \  // \u6700\u5C0F\u30AB\u30C3\u30C8\u306E\u8A2D\u5B9A\n    Project_Selection_Problem<ll>\
    \ B(N + M + K);\n    vector<int> X(N + 1), Y(M + 1), Z(K + 1);\n\n    iota(X.begin()\
    \ + 1, X.end(), 0);\n    iota(Y.begin() + 1, Y.end(), N );\n    iota(Z.begin()\
    \ + 1, Z.end(), N + M );\n\n    auto inf = Extended_Algebra<ll>::inf;\n\n    for\
    \ (int i = 1; i <= N; i++) {\n        B.set_one(X[i], E[i]);\n        for (int\
    \ a: A[i]) {\n            B.set_zero_one(Z[a], X[i], -inf);\n        }\n    }\n\
    \n    for (int j = 1; j <= M; j++) {\n        B.set_zero(Y[j], F[j]);\n    }\n\
    \n    for (int p = 0; p < P; p++) { B.set_zero_one(Y[J[p]], X[I[p]], -inf); }\n\
    \    for (int k = 1; k <= K; k++) { B.set_one(Z[k], -V[k]); }\n\n    // \u6700\
    \u5C0F\u30AB\u30C3\u30C8\u3092\u89E3\u304F.\n    B.solve();\n    auto choice =\
    \ B.choice;\n\n    // \u89E3\u306E\u8A08\u7B97\n    vector<int> goals, actions,\
    \ preparations;\n    for (int i = 1; i <= N; i++) {\n        if (choice[X[i]])\
    \ goals.emplace_back(i);\n    }\n\n    for (int j = 1; j <= M; j++) {\n      \
    \  if (!choice[Y[j]]) actions.emplace_back(j);\n    }\n\n    for (int k = 1; k\
    \ <= K; k++) {\n        if (choice[Z[k]]) preparations.emplace_back(k);\n    }\n\
    \n    // \u89E3\u306E\u51FA\u529B\n    cout << B.ans << endl;\n    cout << (goals.size()\
    \ + actions.size() + preparations.size()) << endl;\n\n    for (int k: preparations)\
    \ { cout << \"Preparation \" << k << endl; }\n    for (int i: goals) { cout <<\
    \ \"Goal \" << i << endl; }\n    for (int j: actions) { cout << \"Action \" <<\
    \ j << endl; }\n}\n\nint main() {\n    verify();\n}\n"
  code: "#define PROBLEM \"https://yukicoder.me/problems/no/1984\"\n\n#include\"../../template/template.hpp\"\
    \n#include\"../../Max_Flow/Project_Selection_Problem.hpp\"\n\nusing namespace\
    \ projection_selection_problem;\n\nvoid verify() {\n    // \u5909\u6570\u4EE3\u5165\
    \n    int N, M, K, P; cin >> N >> M >> K >> P;\n    vector<ll> E(N + 1), F(M +\
    \ 1), V(K + 1);\n    for (int i = 1; i <= N; i++) { cin >> E[i]; }\n    for (int\
    \ j = 1; j <= M; j++) { cin >> F[j]; }\n    for (int k = 1; k <= K; k++) { cin\
    \ >> V[k]; }\n\n    vector<int> L(N + 1);\n    vector<vector<int>> A(N + 1);\n\
    \n    for (int i = 1; i <= N; i++) {\n        cin >> L[i];\n        A[i].resize(L[i]);\n\
    \        for (int t = 0; t < L[i]; t++) { cin >> A[i][t]; }\n    }\n\n    vector<int>\
    \ I(P), J(P);\n    for (int p = 0; p < P; p++) { cin >> I[p] >> J[p]; }\n\n  \
    \  // \u6700\u5C0F\u30AB\u30C3\u30C8\u306E\u8A2D\u5B9A\n    Project_Selection_Problem<ll>\
    \ B(N + M + K);\n    vector<int> X(N + 1), Y(M + 1), Z(K + 1);\n\n    iota(X.begin()\
    \ + 1, X.end(), 0);\n    iota(Y.begin() + 1, Y.end(), N );\n    iota(Z.begin()\
    \ + 1, Z.end(), N + M );\n\n    auto inf = Extended_Algebra<ll>::inf;\n\n    for\
    \ (int i = 1; i <= N; i++) {\n        B.set_one(X[i], E[i]);\n        for (int\
    \ a: A[i]) {\n            B.set_zero_one(Z[a], X[i], -inf);\n        }\n    }\n\
    \n    for (int j = 1; j <= M; j++) {\n        B.set_zero(Y[j], F[j]);\n    }\n\
    \n    for (int p = 0; p < P; p++) { B.set_zero_one(Y[J[p]], X[I[p]], -inf); }\n\
    \    for (int k = 1; k <= K; k++) { B.set_one(Z[k], -V[k]); }\n\n    // \u6700\
    \u5C0F\u30AB\u30C3\u30C8\u3092\u89E3\u304F.\n    B.solve();\n    auto choice =\
    \ B.choice;\n\n    // \u89E3\u306E\u8A08\u7B97\n    vector<int> goals, actions,\
    \ preparations;\n    for (int i = 1; i <= N; i++) {\n        if (choice[X[i]])\
    \ goals.emplace_back(i);\n    }\n\n    for (int j = 1; j <= M; j++) {\n      \
    \  if (!choice[Y[j]]) actions.emplace_back(j);\n    }\n\n    for (int k = 1; k\
    \ <= K; k++) {\n        if (choice[Z[k]]) preparations.emplace_back(k);\n    }\n\
    \n    // \u89E3\u306E\u51FA\u529B\n    cout << B.ans << endl;\n    cout << (goals.size()\
    \ + actions.size() + preparations.size()) << endl;\n\n    for (int k: preparations)\
    \ { cout << \"Preparation \" << k << endl; }\n    for (int i: goals) { cout <<\
    \ \"Goal \" << i << endl; }\n    for (int j: actions) { cout << \"Action \" <<\
    \ j << endl; }\n}\n\nint main() {\n    verify();\n}\n"
  dependsOn:
  - template/template.hpp
  - template/utility.hpp
  - template/math.hpp
  - template/inout.hpp
  - template/macro.hpp
  - template/bitop.hpp
  - template/exception.hpp
  - Max_Flow/Project_Selection_Problem.hpp
  - Algebra/Extended_Algebra.hpp
  - Max_Flow/Max_Flow.hpp
  isVerificationFile: true
  path: verify/yukicoder/1984.test.cpp
  requiredBy: []
  timestamp: '2026-02-28 23:52:49+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: verify/yukicoder/1984.test.cpp
layout: document
redirect_from:
- /verify/verify/yukicoder/1984.test.cpp
- /verify/verify/yukicoder/1984.test.cpp.html
title: verify/yukicoder/1984.test.cpp
---
